# Azure DevOps Application Pipeline
# FinRisk Platform - Applicant Validator Build & Deploy Only
#
# This pipeline handles application CI/CD:
# - Build, test, lint Docker image
# - Deploy to Azure Container Apps
# - Branch-based environment targeting:
#   - dev branch -> dev environment
#   - main branch -> prod environment
# - Assumes infrastructure already exists (use infra pipeline first)
#
# Agent: self-hosted macOS (pool: Default) with OrbStack for Docker

name: FinRisk-App-CI-CD-$(Date:yyyyMMdd-HHmm)$(Rev:.r)

trigger:
  branches:
    include:
      - dev
  paths:
    include:
      - app/**
      - pipelines/azure-pipelines-app.yml

pr:
  branches:
    include:
      - dev
  paths:
    include:
      - app/**

variables:
  # Common variables
  - name: azureSubscription
    value: 'azure-service-connection'
  - name: pythonVersion
    value: '3.13'
  - name: imageName
    value: 'applicant-validator'
  - name: dockerRegistryServiceConnection
    value: 'acr-service-connection'

  # Branch-based environment targeting
  - ${{ if eq(variables['Build.SourceBranch'], 'refs/heads/main') }}:
    - name: environmentName
      value: 'prod'
    - name: containerAppName
      value: 'ca-finrisk-prod'
    - name: resourceGroupName
      value: 'rg-finrisk-prod'
    - name: containerRegistry
      value: 'acrfinriskprod.azurecr.io'
    - group: finrisk-app-prod

  - ${{ if eq(variables['Build.SourceBranch'], 'refs/heads/dev') }}:
    - name: environmentName
      value: 'dev'
    - name: containerAppName
      value: 'ca-finrisk-dev'
    - name: resourceGroupName
      value: 'rg-finrisk-dev'
    - name: containerRegistry
      value: 'acrfinriskdev.azurecr.io'
    - group: finrisk-app-dev

  # Default to dev for PRs and other branches
  - ${{ if and(ne(variables['Build.SourceBranch'], 'refs/heads/main'), ne(variables['Build.SourceBranch'], 'refs/heads/dev')) }}:
    - name: environmentName
      value: 'dev'
    - name: containerAppName
      value: 'ca-finrisk-dev'
    - name: resourceGroupName
      value: 'rg-finrisk-dev'
    - name: containerRegistry
      value: 'acrfinriskdev.azurecr.io'
    - group: finrisk-app-dev

stages:
  # ========================================
  # STAGE 1: BUILD & TEST
  # ========================================
  - stage: Build
    displayName: 'Build & Test'
    jobs:
      - job: Test
        pool: Default
        steps:
          - checkout: self
            fetchDepth: 1      # Shallow fetch (faster)
            clean: false       # Skip cleanup on local agent

          - script: |
              echo "Branch: $(Build.SourceBranch)"
              echo "Environment: $(environmentName)"
              echo "Container App: $(containerAppName)"
              echo "Resource Group: $(resourceGroupName)"
              echo "Registry: $(containerRegistry)"
            displayName: 'Show Environment Info'

          - script: |
              echo "##vso[task.prependpath]/opt/homebrew/opt/python@3.13/bin"
              echo "##vso[task.prependpath]$HOME/.local/bin"
            displayName: 'Setup Python PATH'

          - script: |
              uv --version || (curl -LsSf https://astral.sh/uv/install.sh | sh)
            displayName: 'Verify uv'

          - script: |
              cd app && uv sync --extra dev
            displayName: 'Install Dependencies'

          - script: |
              cd app && uv run ruff check src/ --output-format=github
            displayName: 'Lint (Ruff)'
            continueOnError: true  # Non-blocking: lint issues don't fail the build

          - script: |
              cd app && uv run mypy src/
            displayName: 'Type Check (mypy)'
            continueOnError: true  # Non-blocking: type issues don't fail the build

          - script: |
              cd app && uv run bandit -r src/ -c pyproject.toml
            displayName: 'Security Scan (Bandit)'
            continueOnError: true  # Non-blocking: security warnings don't fail the build

          - script: |
              cd app && uv run pytest tests/unit/ \
                --junitxml=junit/test-results.xml \
                --cov=src --cov-report=xml --cov-report=html
            displayName: 'Run Unit Tests'

          - task: PublishTestResults@2
            condition: succeededOrFailed()
            inputs:
              testResultsFormat: 'JUnit'
              testResultsFiles: '**/test-*.xml'

          - task: PublishCodeCoverageResults@2
            condition: succeededOrFailed()
            continueOnError: true  # Non-blocking: publish timeout doesn't fail the build
            inputs:
              codeCoverageTool: 'Cobertura'
              summaryFileLocation: '$(System.DefaultWorkingDirectory)/app/coverage.xml'

      - job: BuildImage
        dependsOn: Test
        pool: Default
        steps:
          - checkout: self
            fetchDepth: 0      # Full history needed for git describe
            clean: false       # Skip cleanup on local agent

          - script: |
              # Semantic versioning from git tags
              # Format: v{major}.{minor}.{patch}-{commits}-g{hash} (e.g., v0.1.0-5-gabc123)
              # Falls back to v0.0.0-{commits}-g{hash} if no tags exist
              VERSION=$(git describe --tags --always --dirty 2>/dev/null || echo "v0.0.0-$(git rev-parse --short HEAD)")
              echo "Generated version: $VERSION"

              # Set variable for same-job use
              echo "##vso[task.setvariable variable=imageTag]$VERSION"

              # Save to file for cross-stage use (more reliable than output variables)
              echo "$VERSION" > $(Build.ArtifactStagingDirectory)/image-tag.txt
            displayName: 'SetVersion'
            name: SetVersion

          - publish: $(Build.ArtifactStagingDirectory)/image-tag.txt
            artifact: image-tag
            displayName: 'Publish Image Tag'

          - script: |
              # OrbStack Docker on macOS self-hosted agent
              # $HOME resolves to the agent user's home directory at runtime
              export DOCKER=$HOME/.orbstack/bin/docker
              export DOCKER_CONFIG=$HOME/.docker

              echo "Using Docker: $DOCKER"
              $DOCKER --version
              $DOCKER buildx version

              # Login to ACR using Azure CLI (works with OrbStack)
              echo "Logging in to ACR..."
              az acr login --name acrfinriskdev

              # Setup buildx builder
              echo "Setting up buildx builder..."
              $DOCKER buildx create --name mybuilder --use 2>/dev/null || $DOCKER buildx use mybuilder
              $DOCKER buildx inspect --bootstrap

              echo "Buildx setup complete!"
            displayName: 'Setup Docker Buildx and Login'

          - script: |
              set -e

              # OrbStack Docker on macOS self-hosted agent
              DOCKER=$HOME/.orbstack/bin/docker
              export DOCKER_CONFIG=$HOME/.docker

              # Navigate to app directory
              cd app
              echo "Building in: $(pwd)"

              # Build and push
              echo "Starting Docker buildx build..."
              $DOCKER buildx build \
                --platform linux/amd64 \
                --target production \
                -t $(containerRegistry)/$(imageName):$(imageTag) \
                -t $(containerRegistry)/$(imageName):latest \
                --push \
                .

              echo "Build and push completed successfully!"
            displayName: 'Build and Push Docker Image (AMD64)'

          - task: trivy@2
            displayName: 'Scan Image (Trivy)'
            inputs:
              type: 'image'
              target: '$(containerRegistry)/$(imageName):$(imageTag)'
              severities: 'CRITICAL,HIGH,MEDIUM'
              'exit-code': 0  # Don't fail build on findings
              reports: 'html,junit'
              publish: true
            continueOnError: true  # Fallback: ensure pipeline continues

          - task: sbom-tool@1
            displayName: 'Generate SBOM Manifest'
            inputs:
              command: 'generate'
              buildSourcePath: '$(Build.SourcesDirectory)'
              buildArtifactPath: '$(Build.ArtifactStagingDirectory)'
              enableManifestSpreadsheetGeneration: true
              enableManifestGraphGeneration: true
              enablePackageMetadataParsing: true
              fetchLicenseInformation: true
              fetchSecurityAdvisories: true
              packageSupplier: 'FinSure Capital'
              packageName: 'applicant-validator'
              packageVersion: '$(Build.BuildNumber)'

          - publish: $(Build.ArtifactStagingDirectory)/_manifest
            artifact: SBOM
            displayName: 'Publish SBOM Artifact'

  # ========================================
  # STAGE 2: DEPLOY
  # ========================================
  - stage: Deploy
    displayName: 'Deploy to Container Apps'
    dependsOn: Build
    condition: succeeded()
    jobs:
      - deployment: DeployContainerApp
        pool: Default
        # Environment enables approvals in Azure DevOps
        # Create 'prod' environment with approvers for production
        environment: finrisk-app-$(environmentName)
        strategy:
          runOnce:
            deploy:
              steps:
                - download: current
                  artifact: image-tag
                  displayName: 'Download Image Tag'

                - script: |
                    # Read image tag from artifact
                    IMAGE_TAG=$(cat $(Pipeline.Workspace)/image-tag/image-tag.txt)
                    echo "Image tag: $IMAGE_TAG"
                    echo "##vso[task.setvariable variable=imageTag]$IMAGE_TAG"
                  displayName: 'Read Image Tag'

                - task: AzureCLI@2
                  displayName: 'Update Container App'
                  inputs:
                    azureSubscription: '$(azureSubscription)'
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      echo "Deploying image: $(containerRegistry)/$(imageName):$(imageTag)"
                      echo "Target: $(containerAppName) in $(resourceGroupName)"
                      az containerapp update \
                        --name $(containerAppName) \
                        --resource-group $(resourceGroupName) \
                        --image $(containerRegistry)/$(imageName):$(imageTag) \
                        --output table

                - script: sleep 30
                  displayName: 'Wait for Deployment'
                  # Allow time for container rollout and DNS propagation

  # ========================================
  # STAGE 3: VERIFY
  # ========================================
  - stage: Verify
    displayName: 'Smoke Tests'
    dependsOn: Deploy
    jobs:
      - job: SmokeTests
        pool: Default
        steps:
          - task: AzureCLI@2
            displayName: 'Get App URL'
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                APP_URL=$(az containerapp show \
                  --name $(containerAppName) \
                  --resource-group $(resourceGroupName) \
                  --query properties.configuration.ingress.fqdn \
                  --output tsv)
                echo "App URL: https://$APP_URL"
                echo "##vso[task.setvariable variable=appUrl]https://$APP_URL"

          - script: |
              # Retry loop handles cold start (scale-to-zero) and rollout delays
              # 10 retries * 10s = 100s max wait time
              HEALTH_URL="$(appUrl)/health"
              echo "Health check URL: $HEALTH_URL"
              echo ""

              for i in {1..10}; do
                RESPONSE=$(curl -s -w "\n%{http_code}" "$HEALTH_URL" 2>/dev/null)
                STATUS=$(echo "$RESPONSE" | tail -n1)
                BODY=$(echo "$RESPONSE" | sed '$d')

                echo "Attempt $i/10: HTTP $STATUS"

                if [ "$STATUS" = "200" ]; then
                  echo ""
                  echo "Health check passed"
                  echo "Response: $BODY"
                  exit 0
                fi

                echo "Response: $BODY"
                echo "Retrying in 10s..."
                sleep 10
              done

              echo ""
              echo "Health check failed after 10 attempts"
              exit 1
            displayName: 'Health Check'

          - script: |
              echo "============================================"
              echo "Endpoint Verification"
              echo "============================================"
              echo ""

              # Check OpenAPI docs - verify HTML content
              echo "1. OpenAPI Documentation (/docs)"
              echo "   URL: $(appUrl)/docs"
              DOCS_RESPONSE=$(curl -s -w "\n%{http_code}" "$(appUrl)/docs")
              DOCS_STATUS=$(echo "$DOCS_RESPONSE" | tail -n1)
              DOCS_BODY=$(echo "$DOCS_RESPONSE" | sed '$d')

              echo "   HTTP Status: $DOCS_STATUS"

              if [ "$DOCS_STATUS" != "200" ]; then
                echo "   ERROR: Expected HTTP 200"
                exit 1
              fi

              # Verify docs contains expected content
              if echo "$DOCS_BODY" | grep -q "swagger"; then
                echo "   Content: Valid OpenAPI/Swagger UI detected"
              elif echo "$DOCS_BODY" | grep -q "openapi"; then
                echo "   Content: Valid OpenAPI documentation detected"
              else
                echo "   WARNING: Could not verify OpenAPI content"
              fi
              echo "   Result: PASSED"
              echo ""

              # Check readiness probe - validate JSON response
              echo "2. Readiness Probe (/ready)"
              echo "   URL: $(appUrl)/ready"
              READY_RESPONSE=$(curl -s -w "\n%{http_code}" "$(appUrl)/ready")
              READY_STATUS=$(echo "$READY_RESPONSE" | tail -n1)
              READY_BODY=$(echo "$READY_RESPONSE" | sed '$d')

              echo "   HTTP Status: $READY_STATUS"

              if [ "$READY_STATUS" != "200" ]; then
                echo "   ERROR: Expected HTTP 200"
                echo "   Response: $READY_BODY"
                exit 1
              fi

              # Parse and validate JSON response
              READY_VALUE=$(echo "$READY_BODY" | jq -r '.ready' 2>/dev/null)
              if [ "$READY_VALUE" = "true" ]; then
                echo "   Ready: $READY_VALUE"
                # Show individual checks if present
                CHECKS=$(echo "$READY_BODY" | jq -r '.checks | to_entries | map("\(.key)=\(.value)") | join(", ")' 2>/dev/null)
                if [ -n "$CHECKS" ]; then
                  echo "   Checks: $CHECKS"
                fi
                echo "   Result: PASSED"
              else
                echo "   ERROR: Expected ready=true, got '$READY_VALUE'"
                echo "   Response: $READY_BODY"
                exit 1
              fi
              echo ""

              # Summary
              echo "============================================"
              echo "Endpoint Verification: ALL CHECKS PASSED"
              echo "============================================"
            displayName: 'Endpoint Checks'

          - script: |
              echo "============================================"
              echo "Business Logic Verification"
              echo "============================================"
              echo ""

              VALIDATE_URL="$(appUrl)/api/v1/validate"
              REQUEST_BODY='{"firstName":"Jane","lastName":"Doe","idNumber":"9001011234088"}'

              echo "POST $VALIDATE_URL"
              echo "Request: $REQUEST_BODY"
              echo ""

              # Call the validate API with timing (python3 for cross-platform milliseconds)
              START_TIME=$(python3 -c "import time; print(int(time.time() * 1000))")
              RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "$VALIDATE_URL" \
                -H "Content-Type: application/json" \
                -d "$REQUEST_BODY")
              END_TIME=$(python3 -c "import time; print(int(time.time() * 1000))")
              RESPONSE_TIME=$((END_TIME - START_TIME))

              # Extract HTTP status code (last line)
              HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
              # Extract response body (everything except last line)
              BODY=$(echo "$RESPONSE" | sed '$d')

              echo "Response Time: ${RESPONSE_TIME}ms"
              echo "HTTP Status: $HTTP_CODE"
              echo ""

              # Verify HTTP 200
              if [ "$HTTP_CODE" != "200" ]; then
                echo "ERROR: Expected HTTP 200, got $HTTP_CODE"
                echo "Response: $BODY"
                exit 1
              fi
              echo "  HTTP Status: PASSED"

              # Verify response contains required fields
              RISK_SCORE=$(echo "$BODY" | jq -r '.riskScore // empty')
              if [ -z "$RISK_SCORE" ]; then
                echo "  ERROR: Response missing 'riskScore' field"
                echo "  Response: $BODY"
                exit 1
              fi
              echo "  riskScore: $RISK_SCORE (int)"

              RISK_LEVEL=$(echo "$BODY" | jq -r '.riskLevel // empty')
              if [ -z "$RISK_LEVEL" ]; then
                echo "  ERROR: Response missing 'riskLevel' field"
                echo "  Response: $BODY"
                exit 1
              fi

              # Verify riskLevel is valid enum value
              if [[ ! "$RISK_LEVEL" =~ ^(LOW|MEDIUM|HIGH|CRITICAL)$ ]]; then
                echo "  ERROR: Invalid riskLevel value: $RISK_LEVEL"
                exit 1
              fi
              echo "  riskLevel: $RISK_LEVEL (enum)"

              CORRELATION_ID=$(echo "$BODY" | jq -r '.correlationId // empty')
              if [ -z "$CORRELATION_ID" ]; then
                echo "  ERROR: Response missing 'correlationId' field"
                echo "  Response: $BODY"
                exit 1
              fi
              echo "  correlationId: $CORRELATION_ID (uuid)"

              echo ""
              echo "============================================"
              echo "Business Logic Verification: ALL CHECKS PASSED"
              echo "============================================"
            displayName: 'Test Validate API'
